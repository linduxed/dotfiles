#!/usr/bin/env ruby

require 'date'

class TodoFileParser
  TODOWithNumber = Struct.new(:line, :number)

  def initialize(todo_file_path)
    @todo_file_path = todo_file_path
  end

  def mits
    todo_lines = File.readlines(@todo_file_path)
    chomped_lines = todo_lines.map(&:chomp)

    all_todos = chomped_lines.map.with_index do |line, index|
      # todo.sh uses the line numbers of the tasks as their IDs.
      # The IDs are 1-indexed, which is why `index` is incremented by 1.
      TODOWithNumber.new(line, index + 1)
    end

    not_completed_todos = all_todos.reject do |todo|
      todo.line.start_with?('x ')
    end

    not_completed_todos.
      select { |todo| todo.line.match(Constants::MIT_DATE_REGEX) }.
      map { |todo| MIT.new(todo.line, todo.number) }
  end
end

class DateFormatter
  def initialize(date)
    @date = date
  end

  def format
    raise(StandardError, 'Cannot format date prior to today') if @date < Constants::TODAY

    case
    when today?
      'Today:'
    when tomorrow?
      "Tomorrow, #{weekday}:"
    when within_seven_days?
      "#{weekday}:"
    when next_week?
      "#{weekday}, next week, #{@date}:"
    else
      "#{weekday}, #{number_of_weeks_from_now} weeks from now, #{@date}:"
    end
  end

  private

  def today?
    @date == Constants::TODAY
  end

  def tomorrow?
    @date == Constants::TODAY + 1
  end

  def within_seven_days?
    @date <= Constants::TODAY + 7
  end

  def next_week?
    @date.cweek == (Constants::TODAY + 7).cweek
  end

  def number_of_weeks_from_now
    # To account for potential transitions between years when counting weeks
    # into the future, step forward week by week and check if the date of the
    # first day that week matches.
    #
    # As the case-statement above has already handled the "next week"-case,
    # start from two weeks into the future.
    two_weeks = 14
    days_in_week = 7

    days_away_from_matching_week =
      (two_weeks..Float::INFINITY).
      step(days_in_week).
      find do |days_into_future|
        future = Constants::TODAY + days_into_future.to_i

        start_of_week_for_date = @date - @date.cwday
        start_of_week_in_future = future - future.cwday

        start_of_week_for_date == start_of_week_in_future
      end.to_i

    days_away_from_matching_week / days_in_week
  end

  def weekday
    Date::DAYNAMES[@date.wday]
  end
end

class DateParser
  def initialize(date_string)
    @date_string = date_string.downcase
  end

  def parse
    maybe_fixed_date || maybe_weekday || maybe_constraint_free_parse
  end

  private

  def maybe_fixed_date
    fixed_dates = {
      'today' => Constants::TODAY,
      'tomorrow' => Constants::TODAY + 1,
    }

    fixed_dates.fetch(@date_string, nil)
  end

  def maybe_weekday
    weekday_name_to_cwday = {
      'monday' => 1,
      'tuesday' => 2,
      'wednesday' => 3,
      'thursday' => 4,
      'friday' => 5,
      'saturday' => 6,
      'sunday' => 7,
      'mon' => 1,
      'tue' => 2,
      'wed' => 3,
      'thu' => 4,
      'fri' => 5,
      'sat' => 6,
      'sun' => 7,
    }

    return nil unless weekday_name_to_cwday.keys.include?(@date_string)

    from_tomorrow_to_one_week_from_now = (1..7).map do |days_into_future|
      Constants::TODAY + days_into_future
    end

    from_tomorrow_to_one_week_from_now.find do |day|
      day.cwday == weekday_name_to_cwday[@date_string]
    end
  end

  def maybe_constraint_free_parse
    Date.parse(@date_string)
  rescue ArgumentError
    nil
  end
end

class MIT
  def initialize(todo, number)
    @todo = todo
    @number = number
  end

  def date
    @date ||= Date.parse(@todo.match(Constants::MIT_DATE_REGEX)[1])
  end

  def to_s
    @to_s ||= "#{priority_token}#{task} (#{@number})"
  end

  def past_due?
    date < Constants::TODAY
  end

  def context?(context)
    @todo.match(/#{context}/)
  end

  private

  def task
    @todo.split(Constants::MIT_DATE_REGEX).last.strip
  end

  def priority_token
    if p = @todo.match(/\A\([A-Z]\) /) then p[0] else nil end
  end
end

class MITListPrinter
  def initialize(todo_file_path)
    @todo_file_path = todo_file_path
  end

  def all_mits
    return 'No MITs found.' if mits_from_file.empty?

    grouped_by_date(mits_from_file)
  end

  def mits_with_context(context:)
    context_mits = mits_from_file.select { |mit| mit.context?(context) }
    return 'No MITs found.' if context_mits.empty?

    grouped_by_date(context_mits)
  end

  def mits_without_context(context:)
    not_context_mits = mits_from_file.reject { |mit| mit.context?(context) }
    return 'No MITs found.' if not_context_mits.empty?

    grouped_by_date(not_context_mits)
  end

  private

  def mits_from_file
    @mits_from_file ||= TodoFileParser.new(@todo_file_path).mits
  end

  def grouped_by_date(mits)
    output_lines = []

    if mits.any?(&:past_due?)
      output_lines << 'Past due:'
      mits.select(&:past_due?).each do |mit|
        output_lines << "  #{mit}"
      end
      output_lines << ''
    end

    mits_today_or_in_future = mits.reject(&:past_due?).group_by(&:date)
    sorted_dates = mits_today_or_in_future.keys.sort

    sorted_dates.each do |date|
      mits_for_date = mits_today_or_in_future[date]

      output_lines << DateFormatter.new(date).format
      mits_for_date.each do |mit|
        output_lines << "  #{mit}"
      end
      output_lines << ''
    end

    output_lines.join("\n")
  end
end

class BadDateError < StandardError; end
class BadTaskIDError < StandardError; end
class MITDateMissingError < StandardError; end

class TodoFileMutator
  def initialize(todo_file_path)
    @todo_file_path = todo_file_path
  end

  def add_mit(date:, task:, include_creation_date:)
    parsed_date = DateParser.new(date).parse
    raise(BadDateError, "\"#{date}\" is not a valid date.") unless parsed_date
    mit_date = parsed_date.strftime('%Y.%m.%d')

    optional_creation_date =
      if include_creation_date
        "#{Constants::TODAY} "
      else
        ''
      end
    mit = "#{optional_creation_date}{#{mit_date}} #{task}"

    write_mit_at_end_of_todo_file(mit)

    "#{mit}\nTODO: #{number_of_todos_in_todo_file} added."
  end

  def move_or_make_mit(task_id:, date:)
    all_tasks = File.readlines(@todo_file_path)
    task = maybe_find_task(task_id, all_tasks)
    raise(BadTaskIDError, "No task for ID: #{task_id}") unless task

    parsed_date = DateParser.new(date).parse
    raise(BadDateError, "\"#{date}\" is not a valid date.") unless parsed_date
    mit_date = "{#{parsed_date.strftime('%Y.%m.%d')}}"

    changed_task =
      if already_has_mit_date?(task)
        change_mit_date(task, mit_date)
      else
        add_mit_date(task, mit_date)
      end
    all_tasks[task_id.to_i - 1] = changed_task
    overwrite_todo_file(all_tasks)

    "TODO: '#{task.chomp}' moved to #{parsed_date}"
  end

  def remove_mit_date(task_id:)
    all_tasks = File.readlines(@todo_file_path)
    task = maybe_find_task(task_id, all_tasks)
    raise(BadTaskIDError, "No task for ID: #{task_id}") unless task

    unless already_has_mit_date?(task)
      raise(MITDateMissingError, "Task #{task_id} is not a MIT: '#{task.chomp}'")
    end

    changed_task = task.gsub(/#{Constants::MIT_DATE_REGEX} /, '')
    all_tasks[task_id.to_i - 1] = changed_task
    overwrite_todo_file(all_tasks)

    "TODO: Removed MIT date from '#{changed_task.chomp}'"
  end

  private

  def write_mit_at_end_of_todo_file(mit)
    File.open(@todo_file_path, 'a') { |file| file.puts(mit) }
  end

  def number_of_todos_in_todo_file
    File.foreach(@todo_file_path).reduce(0) { |count| count + 1 }
  end

  def already_has_mit_date?(task)
    task.match(Constants::MIT_DATE_REGEX)
  end

  def maybe_find_task(task_id, tasks)
    id = task_id.to_i # Note: String#to_i on non-numbers returns 0.

    return nil if id <= 0
    return nil if tasks.count < id

    tasks[id - 1]
  end

  def add_mit_date(task, mit_date)
    priority_regex = /\([A-Z]\)/
    date_regex = /\d{4}-\d{2}-\d{2}/

    if task.start_with?('x ')
      task.gsub(
        /^x ((#{date_regex} ){0,2})(.+)$/,
        "x \\1#{mit_date} \\3"
      )
    else
      task.gsub(
        /^(#{priority_regex} )?(#{date_regex} )?(.+)$/,
        "\\1\\2#{mit_date} \\3"
      )
    end
  end

  def change_mit_date(task, mit_date)
    task.gsub(Constants::MIT_DATE_REGEX, mit_date)
  end

  def overwrite_todo_file(tasks)
    File.write(@todo_file_path, tasks.join)
  end
end

module Constants
  TODAY = ENV.key?('FIXED_DATE') ? Date.parse(ENV['FIXED_DATE']) : Date.today
  MIT_DATE_REGEX = /\{(\d{4}\.\d{2}\.\d{2})\}/
  VERSION = 'v0.5.1'.freeze
end

class CLI
  class BadActionError < StandardError; end

  EX_USAGE = 64

  def run
    case
    when usage_requested_from_todo_help?
      $stdout.puts usage_message
      exit 0
    when %w(usage -h --help).include?(ARGV[1])
      $stdout.puts usage_message
      exit 0
    when %w(-v --version).include?(ARGV[1])
      $stdout.puts version_message
      exit 0
    when ARGV[1].nil?
      listing = MITListPrinter.new(ENV['TODO_FILE']).all_mits
      $stdout.puts listing
      exit 0
    when ARGV[1].match(/@\w+/)
      listing = MITListPrinter.new(ENV['TODO_FILE']).mits_with_context(
        context: ARGV[1]
      )
      $stdout.puts listing
      exit 0
    when ARGV[1] == 'not' && ARGV[2].match(/@\w+/)
      listing = MITListPrinter.new(ENV['TODO_FILE']).mits_without_context(
        context: ARGV[2]
      )
      $stdout.puts listing
      exit 0
    when ARGV[1] == 'mv'
      message = TodoFileMutator.new(ENV['TODO_FILE']).move_or_make_mit(
        task_id: ARGV[2],
        date: ARGV[3],
      )
      $stdout.puts message
      exit 0
    when ARGV[1] == 'rm'
      message = TodoFileMutator.new(ENV['TODO_FILE']).remove_mit_date(
        task_id: ARGV[2],
      )
      $stdout.puts message
      exit 0
    when !ARGV[1].nil? && !ARGV[2].nil?
      message = TodoFileMutator.new(ENV['TODO_FILE']).add_mit(
        date: ARGV[1],
        task: ARGV[2],
        include_creation_date: ENV['TODOTXT_DATE_ON_ADD'],
      )
      $stdout.puts message
      exit 0
    else
      fail BadActionError
    end
  rescue BadDateError, BadTaskIDError, MITDateMissingError => e
    $stderr.puts "MIT: #{e.message}"
    exit EX_USAGE
  rescue BadActionError
    $stderr.puts usage_message
    exit EX_USAGE
  end

  private

  def usage_requested_from_todo_help?
    # Normally the add-on will be invoked as a subcommand (like
    # `todo.sh mit foo`), meaning that the actual mit-action, along with its
    # various arguments, will be placed in ARGV[1] and higher.
    #
    # The only exception to this case is when the add-on is invoked through
    # `todo.sh help`. This command will iterate through all available add-ons
    # and invoke them like `mit usage`, meaning that the action will be present
    # in ARGV[0].

    ARGV[0] == 'usage'
  end

  def usage_message
    usage_message = <<-EOF
      Most Important Tasks (MIT):
        Displays Most Important Tasks (MIT) in todo.txt file, adds new ones or
        turns MIT tasks into standard ones.

        mit [-h|--help|-v|--version] [date|day task] [rm ID]
          [not @context|@context] [mv ID DATE|DAY]

        -h, --help      Displays help message.
        -v, --version   Displays version information.

        mit
          List all MITs with default formatting.

        mit rm ID
          Convert the MIT identified by ID to a standard task.

        mit not @context|@context
          Displays all MIT's not in or in specified context.

        mit DATE|DAY task
          DATE must be in the format of YYYY.MM.DD.
          DAY can be full or short day names, today or tomorrow.

        mit mv ID DATE|DAY
          Move the MIT identified by ID to a new day.
          DATE must be in the format of YYYY.MM.DD.
          DAY can be full or short day names, today or tomorrow.
    EOF

    # Remove leading indentation
    usage_message.gsub(/^#{usage_message.scan(/^[ \t]*(?=\S)/).min}/, '')
  end

  def version_message
    "mit (ruby) #{Constants::VERSION}"
  end
end


CLI.new.run
